<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Precision Draw Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
  .canvas-container { position: relative; width: 90vw; max-width: 400px; margin-top: 10px; }
  canvas { border: 1px solid black; width: 100%; height: auto; touch-action: none; }
  #overlayCanvas { position: absolute; left: 0; top: 0; pointer-events: none; }
  button { margin-top: 10px; padding: 10px 20px; font-size: 16px; }
  select { margin-top: 10px; font-size: 16px; padding: 5px; }
  ul { margin-top: 15px; padding-left: 20px; max-width: 400px; width: 90vw; }
  li { margin-bottom: 4px; }
</style>
</head>
<body>

<button id="modeToggle">Shapes</button>
<select id="polygonSelect"></select>

<p>Score: <span id="scoreFinal">-</span></p>

<div class="canvas-container">
  <canvas id="drawCanvas" width="256" height="256"></canvas>
  <canvas id="overlayCanvas" width="256" height="256"></canvas>
</div>

<button id="submitBtn">Submit / Clear</button>

<h3>Best Scores</h3>
<ul id="bestScoresList"></ul>

<script>
const drawCanvas = document.getElementById('drawCanvas');
const overlayCanvas = document.getElementById('overlayCanvas');
const drawCtx = drawCanvas.getContext('2d');
const overlayCtx = overlayCanvas.getContext('2d');

const scoreFinalEl = document.getElementById('scoreFinal');
const polygonSelect = document.getElementById('polygonSelect');
const submitBtn = document.getElementById('submitBtn');
const modeToggleBtn = document.getElementById('modeToggle');
const bestScoresListEl = document.getElementById('bestScoresList');

let userPoints = [];
let drawing = false;
let overlayShown = false;
let mode = 'Shapes'; // 'Shapes' or 'Countries'

// Persistent best scores across mode switches
const bestScores = {};

// --- Helpers ---
function getMousePos(e){
  const rect = drawCanvas.getBoundingClientRect();
  const scaleX = drawCanvas.width / rect.width;
  const scaleY = drawCanvas.height / rect.height;
  return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
}
function getTouchPos(touch){
  const rect = drawCanvas.getBoundingClientRect();
  const scaleX = drawCanvas.width / rect.width;
  const scaleY = drawCanvas.height / rect.height;
  return { x: (touch.clientX - rect.left) * scaleX, y: (touch.clientY - rect.top) * scaleY };
}
function resampleUniform(points,N){
  if(points.length<2) return points.slice();
  let lens=[0], L=0;
  for(let i=1;i<points.length;i++){
    L += Math.hypot(points[i][0]-points[i-1][0],points[i][1]-points[i-1][1]);
    lens.push(L);
  }
  let out=[];
  for(let i=0;i<N;i++){
    let t = L*(i/(N-1));
    let idx = lens.findIndex(v=>v>=t);
    if(idx<=0) out.push(points[0]);
    else {
      let t0=lens[idx-1], t1=lens[idx];
      let ratio = (t-t0)/(t1-t0);
      const [x0,y0] = points[idx-1];
      const [x1,y1] = points[idx];
      out.push([x0 + ratio*(x1-x0), y0 + ratio*(y1-y0)]);
    }
  }
  return out;
}
function dist(a,b){ return Math.hypot(a[0]-b[0],a[1]-b[1]); }
function chamfer(A,B){
  if(A.length===0 || B.length===0) return Infinity;
  const avgMin = (from,to)=>{
    let total=0;
    for(const p of from){
      let best=Infinity;
      for(const q of to){ const d=dist(p,q); if(d<best) best=d; }
      total += best;
    }
    return total/from.length;
  };
  return 0.5*(avgMin(A,B)+avgMin(B,A));
}
function centroid(points){
  const N = points.length;
  let sumX=0,sumY=0;
  for(const [x,y] of points){ sumX+=x; sumY+=y; }
  return [sumX/N, sumY/N];
}
function averageRadius(points, c){
  let total=0;
  for(const [x,y] of points) total += Math.hypot(x-c[0], y-c[1]);
  return total/points.length;
}
function rotateScaleTranslate(points, angle, scale, c){
  const cosA = Math.cos(angle), sinA = Math.sin(angle);
  return points.map(([x,y])=>{
    const dx = x-c[0], dy = y-c[1];
    const xr = cosA*dx - sinA*dy;
    const yr = sinA*dx + cosA*dy;
    return [c[0] + scale*xr, c[1] + scale*yr];
  });
}
function translatePoints(points, tx, ty){
  return points.map(([x,y])=>[x+tx, y+ty]);
}
function erfinv(x){
  let a = 0.147;
  let ln = Math.log(1-x*x);
  let s = (2/(Math.PI*a) + ln/2);
  return (x<0?-1:1) * Math.sqrt(Math.sqrt(s*s - ln/a) - s);
}
function normInv(p){ return Math.sqrt(2)*erfinv(2*p-1); }
function lhsGaussianSamples(numSamples, mean=0, std=1){
  let uniformSamples = [];
  const interval = 1/numSamples;
  for(let i=0;i<numSamples;i++) uniformSamples.push((i+Math.random())*interval);
  for(let i=uniformSamples.length-1;i>0;i--){
    const j = Math.floor(Math.random()* (i+1));
    [uniformSamples[i], uniformSamples[j]] = [uniformSamples[j], uniformSamples[i]];
  }
  return uniformSamples.map(u => normInv(u)*std + mean);
}
function lhsUniform(numSamples, min, max){
  const interval = (max-min)/numSamples;
  let samples = [];
  for(let i=0;i<numSamples;i++) samples.push(min + interval*i + Math.random()*interval);
  for(let i=samples.length-1;i>0;i--){
    const j = Math.floor(Math.random()* (i+1));
    [samples[i], samples[j]] = [samples[j], samples[i]];
  }
  return samples;
}

// --- Generate n-gon ---
function generateNgon(n, center=[128,128], radius=50, pointsPerEdge=100){
  const vertices = [];
  for(let i=0;i<n;i++){
    const angle = 2*Math.PI*i/n - Math.PI/2; 
    vertices.push([center[0]+radius*Math.cos(angle), center[1]+radius*Math.sin(angle)]);
  }
  const highResPoints = [];
  for(let i=0;i<n;i++){
    const [x0,y0] = vertices[i];
    const [x1,y1] = vertices[(i+1)%n];
    for(let j=0;j<pointsPerEdge;j++){
      const t = j/(pointsPerEdge-1);
      highResPoints.push([x0 + t*(x1-x0), y0 + t*(y1-y0)]);
    }
  }
  return highResPoints;
}

// --- Get shape points ---
async function getShapePoints(shapeValue){
  if(mode === 'Shapes'){
    const polygonMap = { "Triangle":3, "Square":4, "Pentagon":5, "Hexagon":6, "Heptagon":7, "Octagon":8 };
    if(shapeValue in polygonMap) return generateNgon(polygonMap[shapeValue]);
    return [];
  } else if(mode === 'Countries'){
    try{
      const res = await fetch(`countries/${shapeValue}.json`);
      if(res.ok) return await res.json();
    } catch(e){ console.error("Failed to load country:", e); }
    return [];
  }
}

// --- Populate dropdown ---
async function populateDropdownByMode(){
  clearAll();
  polygonSelect.innerHTML = '';
  if(mode==='Shapes'){
    const shapes = ["Triangle","Square","Pentagon","Hexagon","Heptagon","Octagon"];
    shapes.forEach(s=>{
      const opt = document.createElement('option');
      opt.value = s; opt.textContent = s;
      if(s==='Square') opt.selected = true;
      polygonSelect.appendChild(opt);
    });
    modeToggleBtn.textContent = "Shapes";
  } else {
    try{
      const res = await fetch('countries/list.json');
      if(!res.ok) throw new Error("Failed to fetch country list");
      const countries = await res.json();
      countries.forEach((c,i)=>{
        const opt = document.createElement('option');
        opt.value=c; opt.textContent=c;
        if(i===0) opt.selected = true;
        polygonSelect.appendChild(opt);
      });
      modeToggleBtn.textContent = "Countries";
    } catch(e){
      console.error(e);
      const opt = document.createElement('option');
      opt.textContent = "Error loading countries";
      polygonSelect.appendChild(opt);
    }
  }
}

// --- Mode toggle ---
modeToggleBtn.addEventListener('click', async ()=>{
  mode = (mode==='Shapes') ? 'Countries' : 'Shapes';
  await populateDropdownByMode();
});

// --- Drawing events ---
drawCanvas.addEventListener('mousedown', e => {
  drawing = true;
  const p = getMousePos(e);
  drawCtx.beginPath();
  drawCtx.moveTo(p.x,p.y);
  userPoints.push([p.x,p.y]);
});
drawCanvas.addEventListener('mousemove', e => {
  if(!drawing) return;
  const p = getMousePos(e);
  drawCtx.lineTo(p.x,p.y);
  drawCtx.stroke();
  userPoints.push([p.x,p.y]);
});
drawCanvas.addEventListener('mouseup', ()=> drawing=false);
drawCanvas.addEventListener('mouseleave', ()=> drawing=false);
drawCanvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.touches[0];
  drawing = true;
  const p = getTouchPos(touch);
  drawCtx.beginPath();
  drawCtx.moveTo(p.x,p.y);
  userPoints.push([p.x,p.y]);
});
drawCanvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if(!drawing) return;
  const touch = e.touches[0];
  const p = getTouchPos(touch);
  drawCtx.lineTo(p.x,p.y);
  drawCtx.stroke();
  userPoints.push([p.x,p.y]);
});
drawCanvas.addEventListener('touchend', e => { e.preventDefault(); drawing=false; });

// --- Clear ---
function clearAll(){
  drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  userPoints = [];
  drawing = false;
  overlayShown = false;
  scoreFinalEl.textContent="-";
}

// --- Draw points ---
function drawPoints(ctx, points, color='orange', size=2){
  ctx.fillStyle=color;
  for(const [x,y] of points){
    ctx.beginPath();
    ctx.arc(x,y,size,0,2*Math.PI);
    ctx.fill();
  }
}

// --- Update best scores list ---
function updateBestScoresList(){
  const scoresArray = Object.entries(bestScores);
  scoresArray.sort((a,b)=>b[1]-a[1]);
  bestScoresListEl.innerHTML='';
  scoresArray.forEach(([name,score])=>{
    const li = document.createElement('li');
    li.textContent = `${name}: ${score.toFixed(2)}`;
    bestScoresListEl.appendChild(li);
  });
}

// --- Submit / Clear ---
async function handleSubmitOrClear(){
  if(!overlayShown){
    if(userPoints.length===0) return;

    const N = 40;
    const userResampled = resampleUniform(userPoints,N);
    const shapeValue = polygonSelect.value;
    const baseShape = await getShapePoints(shapeValue);
    const polyResampled = resampleUniform(baseShape,N);

    const cUser = centroid(userResampled);
    const baseline = chamfer([cUser], userResampled);

    const cPoly = centroid(polyResampled);
    const H_scale = averageRadius(userResampled,cUser)/averageRadius(polyResampled,cPoly);
    const H_tx = cUser[0]-cPoly[0];
    const H_ty = cUser[1]-cPoly[1];

    let heuristicAligned = rotateScaleTranslate(polyResampled,0,H_scale,cPoly);
    heuristicAligned = translatePoints(heuristicAligned,H_tx,H_ty);

    const NUM_SAMPLES = 10000;
    const txSamples = lhsGaussianSamples(NUM_SAMPLES,0,2);
    const tySamples = lhsGaussianSamples(NUM_SAMPLES,0,2);
    const scaleSamples = lhsGaussianSamples(NUM_SAMPLES,1,0.03);
    const thetaSamples = lhsUniform(NUM_SAMPLES,0,2*Math.PI);

    let bestScorePct = -Infinity;
    let bestTx=0, bestTy=0, bestTheta=0, bestScale=0;
    const cHeuristic = centroid(heuristicAligned);

    for(let i=0;i<NUM_SAMPLES;i++){
      const tx=txSamples[i], ty=tySamples[i], theta=thetaSamples[i], s=scaleSamples[i];
      let candidate = rotateScaleTranslate(heuristicAligned,theta,s,cHeuristic);
      candidate = translatePoints(candidate,tx,ty);
      const scorePct = (1 - chamfer(userResampled,candidate)/baseline)*100;
      if(scorePct>bestScorePct){
        bestScorePct = scorePct;
        bestTx=tx; bestTy=ty; bestTheta=theta; bestScale=s;
      }
    }

    const cBase = centroid(baseShape);
    let finalHighRes = rotateScaleTranslate(baseShape, bestTheta, bestScale*H_scale, cBase);
    finalHighRes = translatePoints(finalHighRes, H_tx+bestTx, H_ty+bestTy);

    drawPoints(overlayCtx, finalHighRes,'orange',1);
    scoreFinalEl.textContent = bestScorePct.toFixed(2);

    // Update best scores
    if(!bestScores[shapeValue] || bestScorePct > bestScores[shapeValue]){
      bestScores[shapeValue] = bestScorePct;
      updateBestScoresList();
    }

    overlayShown = true;
  } else {
    clearAll();
  }
}

// --- Events ---
submitBtn.addEventListener('click', handleSubmitOrClear);
window.addEventListener('keydown', async e=>{
  if(e.key==="Enter"){ e.preventDefault(); await handleSubmitOrClear(); }
});

// --- Initial populate ---
populateDropdownByMode();
</script>
</body>
</html>
