<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Precision Draw Game â€” Updated</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  :root{--maxw:420px}
  body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 18px; gap:8px; }
  .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;align-items:center}
  .canvas-container { position: relative; width: 90vw; max-width: var(--maxw); margin-top: 6px; }
  canvas { border: 1px solid #111; width: 100%; height: auto; touch-action: none; display:block }
  #overlayCanvas { position: absolute; left: 0; top: 0; pointer-events: none; }
  button { padding: 8px 12px; font-size:14px; border-radius:6px }
  select { padding:6px 8px; font-size:14px }
  .info { max-width:var(--maxw); width:90vw; display:flex;justify-content:center; gap:12px; font-size:15px; margin-top:6px; flex-wrap:wrap }
  ul { margin-top: 8px; padding-left: 20px; max-width: var(--maxw); width: 90vw; }
  li { margin-bottom: 4px; }
</style>
</head>
<body>

<div class="controls">
  <button id="modeToggle">Switch to Shapes</button>
  <select id="polygonSelect" aria-label="shape or country"></select>
  <button id="submitBtn">Submit / Clear</button>
</div>

<div class="info">
  <div>Score: <strong id="scoreFinal">-</strong></div>
  <div>Tx (search): <strong id="bestTx">-</strong></div>
  <div>Ty (search): <strong id="bestTy">-</strong></div>
  <div>Scale (search): <strong id="bestScale">-</strong></div>
</div>

<div class="canvas-container">
  <canvas id="drawCanvas" width="384" height="384"></canvas>
  <canvas id="overlayCanvas" width="384" height="384"></canvas>
</div>

<h3 style="margin:6px 0">Best Scores</h3>
<ul id="bestScoresList"></ul>

<script>
// ----------------- Elements -----------------
const drawCanvas = document.getElementById('drawCanvas');
const overlayCanvas = document.getElementById('overlayCanvas');
const drawCtx = drawCanvas.getContext('2d');
const overlayCtx = overlayCanvas.getContext('2d');

const scoreFinalEl = document.getElementById('scoreFinal');
const bestTxEl = document.getElementById('bestTx');
const bestTyEl = document.getElementById('bestTy');
const bestScaleEl = document.getElementById('bestScale');

const polygonSelect = document.getElementById('polygonSelect');
const submitBtn = document.getElementById('submitBtn');
const modeToggleBtn = document.getElementById('modeToggle');
const bestScoresListEl = document.getElementById('bestScoresList');

// ----------------- State -----------------
let userPoints = [];
let drawing = false;
let overlayShown = false;
let mode = 'Countries';
const bestScores = {};

// ----------------- Helpers -----------------
function getMousePos(e){
  const rect = drawCanvas.getBoundingClientRect();
  const scaleX = drawCanvas.width / rect.width;
  const scaleY = drawCanvas.height / rect.height;
  return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
}
function getTouchPos(touch){
  const rect = drawCanvas.getBoundingClientRect();
  const scaleX = drawCanvas.width / rect.width;
  const scaleY = drawCanvas.height / rect.height;
  return { x: (touch.clientX - rect.left) * scaleX, y: (touch.clientY - rect.top) * scaleY };
}

function resampleUniform(points,N){
  if(points.length<2) return points.slice();
  const lens=[0]; let L=0;
  for(let i=1;i<points.length;i++){
    L += Math.hypot(points[i][0]-points[i-1][0], points[i][1]-points[i-1][1]);
    lens.push(L);
  }
  if(L===0) return Array(N).fill(points[0]);
  const out=[];
  for(let i=0;i<N;i++){
    const t = L*(i/(N-1));
    let idx = 0;
    while(idx<lens.length && lens[idx]<t) idx++;
    if(idx<=0) out.push(points[0]);
    else{
      const t0 = lens[idx-1], t1 = lens[idx];
      const ratio = (t - t0) / (t1 - t0 || 1);
      const [x0,y0] = points[idx-1];
      const [x1,y1] = points[idx];
      out.push([ x0 + ratio*(x1-x0), y0 + ratio*(y1-y0) ]);
    }
  }
  return out;
}

function dist(a, b) { return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]); }
function chamfer(A,B){
  if(!A.length || !B.length) return Infinity;
  const avgMin = (from,to)=>{
    let total=0;
    for(const p of from){
      let best=Infinity;
      for(const q of to){ const d=dist(p,q); if(d<best) best=d; }
      total += best;
    }
    return total/from.length;
  };
  return 0.5*(avgMin(A,B) + avgMin(B,A));
}

function centroid(points){
  let sx=0, sy=0;
  for(const [x,y] of points){ sx+=x; sy+=y; }
  return [sx/points.length, sy/points.length];
}

function averageRadius(points, c){
  let total=0; 
  for(const [x,y] of points) total += Math.hypot(x-c[0], y-c[1]);
  return total/(points.length||1);
}

function rotateScaleTranslate(points, angle, scale, c){
  const cosA = Math.cos(angle), sinA = Math.sin(angle);
  return points.map(([x,y])=>{
    const dx = x - c[0], dy = y - c[1];
    const xr = cosA*dx - sinA*dy;
    const yr = sinA*dx + cosA*dy;
    return [ c[0] + scale*xr, c[1] + scale*yr ];
  });
}
function translatePoints(points, tx, ty){
  return points.map(([x,y])=>[x+tx, y+ty]);
}

function erfinv(x){
  const a = 0.147;
  const ln = Math.log(1 - x*x);
  const s = (2/(Math.PI*a) + ln/2);
  return (x<0 ? -1 : 1) * Math.sqrt( Math.sqrt(s*s - ln/a) - s );
}
function normInv(p){ return Math.sqrt(2)*erfinv(2*p-1); }
function lhsGaussianSamples(numSamples, mean=0, std=1){
  let uniform = [];
  const interval = 1/numSamples;
  for(let i=0;i<numSamples;i++) uniform.push( (i + Math.random())*interval );
  for(let i=uniform.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [uniform[i], uniform[j]] = [uniform[j], uniform[i]];
  }
  return uniform.map(u => normInv(u)*std + mean);
}
function lhsUniform(numSamples, min, max){
  const interval = (max-min)/numSamples; 
  let s=[];
  for(let i=0;i<numSamples;i++)
    s.push(min + interval*i + Math.random()*interval);
  for(let i=s.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [s[i], s[j]] = [s[j], s[i]];
  }
  return s;
}

function generateNgon(n, center=[192,192], radius=80, totalPoints=2000){
  const vertices = [];
  for(let i=0;i<n;i++){
    const angle = 2*Math.PI*i/n - Math.PI/2;
    vertices.push([ center[0] + radius*Math.cos(angle),
                    center[1] + radius*Math.sin(angle) ]);
  }
  const points = [];
  const perEdge = Math.ceil(totalPoints/n);
  for(let i=0;i<n;i++){
    const [x0,y0] = vertices[i];
    const [x1,y1] = vertices[(i+1)%n];
    for(let j=0;j<perEdge;j++){
      const t = (perEdge===1) ? 0 : j/(perEdge-1);
      points.push([ x0 + t*(x1-x0), y0 + t*(y1-y0) ]);
    }
  }
  return points.slice(0,totalPoints);
}

async function getShapePoints(shapeValue){
  if(mode === 'Shapes'){
    const polygonMap = { "Circle":100, "Triangle":3, "Square":4, "Pentagon":5, "Hexagon":6, "Heptagon":7, "Octagon":8 };
    if(shapeValue in polygonMap){
      const n = shapeValue === 'Circle' ? 100 : polygonMap[shapeValue];
      return generateNgon(n);
    }
    return [];
  } else {
    try{
      const filename = shapeValue.replace(/ /g,'_');
      const res = await fetch(`countries/${filename}.json`);
      if(res.ok) return await res.json();
    }catch(e){ console.error('Failed to load country', e); }
    return [];
  }
}

// ----------------- UI helpers -----------------
function drawPoints(ctx, points, color='orange', size=1.5){
  ctx.fillStyle = color;
  for(const [x,y] of points){
    ctx.beginPath(); ctx.arc(x,y,size,0,2*Math.PI); ctx.fill();
  }
}
function clearAll(){
  drawCtx.clearRect(0,0,drawCanvas.width, drawCanvas.height);
  overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
  userPoints = [];
  drawing = false;
  overlayShown = false;
  scoreFinalEl.textContent = '-';
  bestTxEl.textContent = '-';
  bestTyEl.textContent = '-';
  bestScaleEl.textContent = '-';
}
function updateBestScoresList(){
  const arr = Object.entries(bestScores).sort((a,b)=>b[1]-a[1]);
  bestScoresListEl.innerHTML = '';
  for(const [k,v] of arr){
    const li=document.createElement('li');
    li.textContent = `${k}: ${v.toFixed(2)}`;
    bestScoresListEl.appendChild(li);
  }
}

// ----------------- Main scoring -----------------
async function handleSubmitOrClear(){
  if(!overlayShown){
    if(userPoints.length<2) return;

    const N = 40;
    const userResampled = resampleUniform(userPoints, N);

    const shapeValue = polygonSelect.value;
    const baseShape = await getShapePoints(shapeValue);
    if(!baseShape.length){ alert('No shape data available'); return; }

    const polyResampled = resampleUniform(baseShape, N);

    // heuristic alignment
    const cUser = centroid(userResampled);
    const cPoly = centroid(polyResampled);
    const H_scale = averageRadius(userResampled, cUser) / averageRadius(polyResampled, cPoly);
    const H_tx = cUser[0] - cPoly[0];
    const H_ty = cUser[1] - cPoly[1];
    let heuristicAligned = rotateScaleTranslate(polyResampled, 0, H_scale, cPoly);
    heuristicAligned = translatePoints(heuristicAligned, H_tx, H_ty);

    const cTarget = centroid(baseShape);
    let baseline = chamfer([cTarget], baseShape);
    if(!isFinite(baseline) || baseline===0) baseline = 1e-6;

    // --------------------- SEARCH ---------------------
    const NUM_SAMPLES = 50000;
    const txSamples = lhsGaussianSamples(NUM_SAMPLES, 0, 4);
    const tySamples = lhsGaussianSamples(NUM_SAMPLES, 0, 4);
    const thetaMin = (mode === 'Shapes') ? -Math.PI : -Math.PI/12;
    const thetaMax = (mode === 'Shapes') ?  Math.PI :  Math.PI/12;
    const thetaSamples = lhsUniform(NUM_SAMPLES, thetaMin, thetaMax);
    const scaleSamples = lhsGaussianSamples(NUM_SAMPLES, 1, 0.03);

    let bestScore = -Infinity;
    let bestTx=0,bestTy=0,bestTheta=0,bestScale=1;
    const cHeuristic = centroid(heuristicAligned);

    for(let i=0;i<NUM_SAMPLES;i++){
      const tx = txSamples[i], ty = tySamples[i];
      const theta = thetaSamples[i], s = scaleSamples[i];

      let candidate = rotateScaleTranslate(heuristicAligned, theta, s, cHeuristic);
      candidate = translatePoints(candidate, tx, ty);

      const rawCham = chamfer(userResampled, candidate);
      const scoreProxy = -rawCham;

      if(scoreProxy > bestScore){
        bestScore = scoreProxy;
        bestTx=tx; bestTy=ty; bestTheta=theta; bestScale=s;
      }
    }

    // apply best transform to base shape
    const cBase = centroid(baseShape);
    const combinedScale = H_scale * bestScale;
    let finalHighRes = rotateScaleTranslate(baseShape, bestTheta, combinedScale, cBase);
    finalHighRes = translatePoints(finalHighRes, H_tx + bestTx, H_ty + bestTy);

    const rawChamferFinal = chamfer(userResampled, finalHighRes);
    let scorePct = (1 - rawChamferFinal / combinedScale / baseline) * 100;
    if(!isFinite(scorePct)) scorePct = -999;

    overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
    overlayCtx.globalAlpha = 0.95;
    drawPoints(overlayCtx, finalHighRes, 'orange', 1);
    overlayCtx.globalAlpha = 1.0;

    // DISPLAY only search contribution
    scoreFinalEl.textContent = scorePct.toFixed(2);
    bestTxEl.textContent = bestTx.toFixed(2);
    bestTyEl.textContent = bestTy.toFixed(2);
    bestScaleEl.textContent = bestScale.toFixed(4);

    if(!bestScores[shapeValue] || scorePct > bestScores[shapeValue]){
      bestScores[shapeValue] = scorePct;
      updateBestScoresList();
    }

    overlayShown = true;

  } else {
    clearAll();
  }
}

// ----------------- Drawing events -----------------
function beginDraw(p){
  drawCtx.beginPath(); 
  drawCtx.moveTo(p.x,p.y); 
  userPoints.push([p.x,p.y]);
}
function continueDraw(p){
  drawCtx.lineTo(p.x,p.y);
  drawCtx.stroke();
  userPoints.push([p.x,p.y]);
}

drawCanvas.addEventListener('mousedown', e => { if(overlayShown) return; drawing=true; beginDraw(getMousePos(e)); });
drawCanvas.addEventListener('mousemove', e => { if(!drawing || overlayShown) return; continueDraw(getMousePos(e)); });
window.addEventListener('mouseup', ()=> drawing=false);
drawCanvas.addEventListener('mouseleave', ()=> drawing=false);

drawCanvas.addEventListener('touchstart', e => { if(overlayShown) return; e.preventDefault(); drawing=true; beginDraw(getTouchPos(e.touches[0])); });
drawCanvas.addEventListener('touchmove', e => { if(!drawing || overlayShown) return; e.preventDefault(); continueDraw(getTouchPos(e.touches[0])); });
drawCanvas.addEventListener('touchend', e => { e.preventDefault(); drawing=false; });

// ----------------- Init + mode switching -----------------
submitBtn.addEventListener('click', handleSubmitOrClear);
window.addEventListener('keydown', async e => { if(e.key === 'Enter'){ e.preventDefault(); await handleSubmitOrClear(); } });
polygonSelect.addEventListener('change', clearAll);

async function populateDropdownByMode(){
  clearAll(); 
  polygonSelect.innerHTML='';

  if(mode === 'Shapes'){
    const shapes = ['Circle','Triangle','Square','Pentagon','Hexagon','Heptagon','Octagon'];
    shapes.forEach(s=>{
      const o=document.createElement('option');
      o.value = o.textContent = s;
      polygonSelect.appendChild(o);
    });
    polygonSelect.value = 'Circle';
    modeToggleBtn.textContent = 'Switch to Countries';

  } else {
    try{
      const res = await fetch('countries/list.json');
      const countries = await res.json();
      countries.forEach(c=>{
        const o=document.createElement('option');
        o.value = c; 
        o.textContent = c.replace(/_/g,' ');
        polygonSelect.appendChild(o);
      });
      if (countries.includes('Australia')) polygonSelect.value = 'Australia';
      modeToggleBtn.textContent = 'Switch to Shapes';
    } catch(e){
      console.warn(e);
      const o=document.createElement('option');
      o.textContent='Countries unavailable';
      polygonSelect.appendChild(o);
    }
  }
}

modeToggleBtn.addEventListener('click', async ()=>{
  mode = (mode==='Shapes') ? 'Countries' : 'Shapes';
  await populateDropdownByMode();
});

populateDropdownByMode();

</script>
</body>
</html>
